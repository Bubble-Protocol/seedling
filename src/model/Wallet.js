// Copyright (c) 2023 Bubble Protocol
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.

/**
 * Abstract superclass for a Wallet used by HushBubble.
 */
export class Wallet {

  /**
   * Indicates whether this wallet exists and is available for connect.  E.g. for Metamask it indicates
   * whether Metamask is installed.
   * 
   * @returns Promise to resolve true if available, or false if not.
   */
  async isAvailable() {
    return Promise.reject(new Error('Wallet.isAvailable is a virtual function and must be implemented'));
  }
  
  /**
   * Indicates whether this wallet is connected and hence available for transactions, etc.
   * 
   * @returns Promise to resolve true if connected, or false if not.
   */
  async isConnected() {
    return Promise.reject(new Error('Wallet.isConnected is a virtual function and must be implemented'));
  }
  
  /**
   * Connect the wallet.
   * 
   * @returns Promise to connect the wallet
   */
  async connect() {
    return Promise.reject(new Error('Wallet.connect is a virtual function and must be implemented'));
  }

  /**
   * Disconnect the wallet.
   * 
   * @returns Promise to disconnect the wallet
   */
  async disconnect() {
    return Promise.reject(new Error('Wallet.disconnect is a virtual function and must be implemented'));
  }
  
  /**
   * Returns the account address of the connected wallet.
   * 
   * @returns {hex-string} the account address
   */
  getAccount() {
    throw new Error('Wallet.getAccount is a virtual function and must be implemented');
  }
  
  /**
   * Returns the blockchain id 
   * 
   * @returns {Number} blockchain id 
   */
  getChain() {
    throw new Error('Wallet.getChain is a virtual function and must be implemented');
  }

  /**
   * Deploys the given contract to the blockchain.
   * 
   * @param {Object} sourceCode object holding the abi and bytecode generated by the smart contract compiler.
   * Has the form {abi: [...], bin: "..."}.
   * @param {Array} params the contract constructor params
   * @param {Object} options optional options object to pass to the wallet
   * @returns Promise to deploy the contract and resolve with the receipt
   */
  async deploy(sourceCode, params, options) {
    return Promise.reject(new Error('Wallet.deploy is a virtual function and must be implemented'));
  }

  /**
   * Transacts with the given contract on the blockchain.
   * 
   * @param {String} contractAddress blockchain address of contract
   * @param {Array} abi the abi generated by the smart contract compiler.
   * @param {String} method the contract method to transact with
   * @param {Array} params parameters to pass to the contract method
   * @param {Object} options optional options to pass to the wallet
   * @returns Promise to send the transaction and resolve with the receipt
   */
  async send(contractAddress, abi, method, params, options) {
    return Promise.reject(new Error('Wallet.send is a virtual function and must be implemented'));
  }

  /**
   * Calls the given contract method on the blockchain.
   * 
   * @param {String} contractAddress blockchain address of contract
   * @param {Array} abi the abi generated by the smart contract compiler.
   * @param {String} method the contract method to transact with
   * @param {Array} params parameters to pass to the contract method
   * @param {Object} options optional options to pass to the wallet
   * @returns Promise to call the contract method and resolve with its return value
   */
  async call(contractAddress, abi, method, params, options) {
    return Promise.reject(new Error('Wallet.call is a virtual function and must be implemented'));
  }
  
  /**
   * Returns the run-time bytecode of the given smart contract.
   * 
   * @param {String} contractAddress blockchain address of contract
   * @param {Object} options optional options to pass to the wallet
   * @returns Promise to retrieve the bytecode from the blockchain
   */
  async getCode(contractAddress, options) {
    return Promise.reject(new Error('Wallet.getCode is a virtual function and must be implemented'));
  }

  /**
   * Encrypt data.
   * 
   * @param {String} data encrypts the given string using the wallet account's encryption key
   * @returns Promise to resolve with the encrypted data
   */
  async encrypt(data) {
    return Promise.reject(new Error('Wallet.encrypt is a virtual function and must be implemented'));
  }

  /**
   * Decrypt data.
   * 
   * @param {String} data decrypts the given string using the wallet account's encryption key
   * @returns Promise to resolve with the decrypted data
   */
  async decrypt(data) {
    return Promise.reject(new Error('Wallet.decrypt is a virtual function and must be implemented'));
  }

  /**
   * Switch to a different blockchain.
   * 
   * @param {Number} chainId The blockchain's unique chain id
   * @returns Promise to switch
   */
  async switchChain(chainId) {
    return Promise.reject(new Error('Wallet.switchChain is a virtual function and must be implemented'));
  }

  /**
   * Signs the given message using the current account's private key
   * 
   * @param {String} msg The message to sign
   * @returns Promise to resolve with the signature as a single hex string (no preceding '0x').
   */
  async sign(msg) {
    return Promise.reject(new Error('Wallet.sign is a virtual function and must be implemented'));
  }

  /**
   * Gets a sign function for use with the Bubble or ContentManager classes.
   * 
   * @returns Sign function of the form (hash) => {return signature}
   */
  getSignFunction() {
    throw new Error('Wallet.getSignFunction is a virtual function and must be implemented');
  }

}
